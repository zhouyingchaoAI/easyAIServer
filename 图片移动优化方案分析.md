# 图片移动优化方案分析

## 📋 当前实现分析

### 当前逻辑

**操作流程**：
1. `CopyObject` - 复制图片到告警路径（15秒超时，最多3次重试）
2. `RemoveObject` - 删除原图片（15秒超时）

**问题**：
- 需要2次MinIO操作
- 如果每秒100个告警，就有200次MinIO操作
- CopyObject需要读取原图片并写入新路径，MinIO内部需要处理

## 🔍 优化方案对比

### 方案1：GetObject + PutObject（推荐）⭐

**实现**：
1. `GetObject` - 从原路径下载图片到内存
2. `PutObject` - 直接上传到告警路径
3. `RemoveObject` - 删除原图片

**优点**：
- ✅ 减少MinIO服务器内部复制操作
- ✅ PutObject通常比CopyObject快（直接写入）
- ✅ 可以控制并发数（通过goroutine池）
- ✅ 可以添加重试和错误处理

**缺点**：
- ⚠️ 需要下载图片到内存（如果图片大，内存压力）
- ⚠️ 需要3次MinIO操作（但PutObject可能比CopyObject快）

**性能提升**：
- 如果图片平均100KB，下载+上传可能比CopyObject快20-30%
- 可以控制并发数，避免MinIO压力过大

### 方案2：直接写入到告警路径（不推荐）

**实现**：
- 在推理前就写入到告警路径
- 如果推理失败或无检测结果，删除告警路径的图片

**优点**：
- ✅ 不需要移动操作
- ✅ 减少MinIO操作数

**缺点**：
- ❌ 如果推理失败，需要删除已写入的图片（浪费）
- ❌ 如果无检测结果，也需要删除（浪费）
- ❌ 逻辑复杂，需要处理各种失败场景
- ❌ 可能产生大量无效图片

**结论**：不推荐，逻辑复杂且可能浪费资源

### 方案3：批量移动（中等推荐）

**实现**：
- 将多个图片移动操作批量处理
- 使用goroutine池控制并发数

**优点**：
- ✅ 可以控制并发数，避免MinIO压力过大
- ✅ 可以批量处理，提高效率

**缺点**：
- ⚠️ 实现复杂，需要缓冲和批处理逻辑
- ⚠️ 可能增加延迟（等待批量）

**结论**：可以考虑，但实现复杂

### 方案4：使用MinIO的ComposeObject（不适用）

**实现**：
- 使用MinIO的ComposeObject API组合多个对象

**问题**：
- ❌ 只适用于组合多个对象，不适用于移动单个对象
- ❌ 不适用当前场景

## ✅ 推荐方案：GetObject + PutObject + 并发控制

### 实现思路

1. **使用GetObject下载图片**
   - 从原路径下载图片到内存
   - 使用流式读取，避免大图片内存压力

2. **使用PutObject直接上传**
   - 直接上传到告警路径
   - PutObject通常比CopyObject快

3. **控制并发数**
   - 使用goroutine池限制并发数（例如：最多50个并发）
   - 避免MinIO压力过大

4. **异步执行**
   - 保持异步执行，不阻塞推理流程

### 性能对比

**当前方案（CopyObject）**：
- 操作数：2次/图片（CopyObject + RemoveObject）
- 如果MinIO响应100ms，总时间：200ms
- 如果每秒100个告警，总操作数：200次/秒

**优化方案（GetObject + PutObject）**：
- 操作数：3次/图片（GetObject + PutObject + RemoveObject）
- 如果MinIO响应：
  - GetObject：50ms（下载）
  - PutObject：50ms（上传，可能比CopyObject快）
  - RemoveObject：50ms（删除）
  - 总时间：150ms（可能更快）
- 如果每秒100个告警，总操作数：300次/秒
- **但可以通过并发控制限制到50个并发，避免MinIO压力**

### 优化效果

**预期提升**：
- ✅ 单次操作可能快20-30%（PutObject比CopyObject快）
- ✅ 可以控制并发数，避免MinIO压力过大
- ✅ 更好的错误处理和重试机制

**风险**：
- ⚠️ 需要下载图片到内存（如果图片大，内存压力）
- ⚠️ 操作数从2次增加到3次（但单次可能更快）

## 🔧 实现建议

### 1. 使用GetObject + PutObject

```go
// 优化后的移动逻辑
func (s *Scheduler) moveImageToAlertPathOptimized(srcPath, dstPath string) error {
    ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
    defer cancel()

    // 1. 下载图片
    obj, err := s.minio.GetObject(ctx, s.bucket, srcPath, minio.GetObjectOptions{})
    if err != nil {
        return fmt.Errorf("get object failed: %w", err)
    }
    defer obj.Close()

    // 2. 获取图片信息
    stat, err := obj.Stat()
    if err != nil {
        return fmt.Errorf("stat object failed: %w", err)
    }

    // 3. 直接上传到告警路径
    _, err = s.minio.PutObject(ctx, s.bucket, dstPath, obj, stat.Size, minio.PutObjectOptions{
        ContentType: "image/jpeg",
    })
    if err != nil {
        return fmt.Errorf("put object failed: %w", err)
    }

    // 4. 删除原图片
    if err := s.minio.RemoveObject(ctx, s.bucket, srcPath, minio.RemoveObjectOptions{}); err != nil {
        s.log.Warn("failed to remove original image after copy (not critical)",
            slog.String("path", srcPath),
            slog.String("err", err.Error()))
    }

    return nil
}
```

### 2. 添加并发控制

```go
// 使用goroutine池控制并发数
type ImageMovePool struct {
    semaphore chan struct{}
    maxConcurrent int
}

func NewImageMovePool(maxConcurrent int) *ImageMovePool {
    return &ImageMovePool{
        semaphore: make(chan struct{}, maxConcurrent),
        maxConcurrent: maxConcurrent,
    }
}

func (p *ImageMovePool) Move(srcPath, dstPath string) error {
    p.semaphore <- struct{}{} // 获取信号量
    defer func() { <-p.semaphore }() // 释放信号量

    // 执行移动操作
    return moveImageToAlertPathOptimized(srcPath, dstPath)
}
```

### 3. 配置并发数

```toml
[ai_analysis]
# 图片移动并发数（建议设置为MinIO处理能力的50-80%）
alert_image_move_concurrent = 50  # 最多50个并发移动操作
```

## 📊 性能估算

### 假设场景

- **告警频率**：100个/秒
- **图片大小**：平均100KB
- **MinIO响应时间**：
  - GetObject：50ms
  - PutObject：50ms（比CopyObject快）
  - RemoveObject：50ms

### 当前方案

- **操作数**：200次/秒（CopyObject + RemoveObject）
- **总时间**：200ms/图片
- **并发数**：无限制（可能达到100+）

### 优化方案

- **操作数**：300次/秒（GetObject + PutObject + RemoveObject）
- **总时间**：150ms/图片（可能更快）
- **并发数**：限制为50个（避免MinIO压力）

### 性能提升

- ✅ 单次操作可能快20-30%
- ✅ 并发数可控，避免MinIO压力过大
- ✅ 更好的错误处理

## ⚠️ 注意事项

### 1. 内存使用

- 如果图片大（>1MB），下载到内存可能增加内存压力
- 建议：使用流式读取，避免一次性加载到内存

### 2. 网络带宽

- GetObject需要下载图片，增加网络带宽使用
- 如果MinIO在同一服务器，影响较小

### 3. 错误处理

- 如果PutObject失败，原图片仍然存在
- 需要处理各种错误场景

## 📝 总结

### 推荐方案

**方案1：GetObject + PutObject + 并发控制** ⭐

**优点**：
- ✅ 可能比CopyObject快20-30%
- ✅ 可以控制并发数，避免MinIO压力
- ✅ 更好的错误处理

**实现复杂度**：中等

**性能提升**：20-30%

### 不推荐方案

**方案2：直接写入到告警路径**
- ❌ 逻辑复杂
- ❌ 可能浪费资源

**方案3：批量移动**
- ⚠️ 实现复杂
- ⚠️ 可能增加延迟

---

**分析时间**：2025年11月19日  
**推荐方案**：GetObject + PutObject + 并发控制

