# 图片移动优化实现说明

## ✅ 已实现的优化

### 1. 保持 CopyObject 方案（最优）

**实现**：
- ✅ 继续使用 `CopyObject` + `RemoveObject` 方案
- ✅ 这是MinIO推荐的移动方式，性能最优

### 2. 添加并发控制（限制50个并发）

**实现**：
- ✅ 在 `Scheduler` 结构体中添加 `moveSemaphore chan struct{}`
- ✅ 默认并发数：50（可配置）
- ✅ 在图片移动goroutine中使用信号量控制并发

**代码位置**：
```go
// scheduler.go
type Scheduler struct {
    // ...
    moveSemaphore chan struct{}  // 图片移动并发控制
}

// 在图片移动时使用
go func(srcPath, dstPath, taskID, taskType, filename string) {
    // 获取并发控制信号量
    s.moveSemaphore <- struct{}{}
    defer func() { <-s.moveSemaphore }()
    
    // 执行移动操作
    // ...
}
```

**配置**：
```toml
[ai_analysis]
alert_image_move_concurrent = 50  # 图片移动最大并发数，默认: 50
```

### 3. 优化超时时间（从15秒降到5秒）

**实现**：
- ✅ 将 `moveImageToAlertPathInternal` 中的超时时间从15秒降到5秒
- ✅ 快速失败，避免长时间等待

**代码位置**：
```go
// moveImageToAlertPathInternal
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)  // 从15秒降到5秒
defer cancel()
```

### 4. 添加监控指标（MinIO响应时间、成功率）

**实现**：
- ✅ 在 `PerformanceMonitor` 中添加MinIO操作监控字段
- ✅ 添加 `RecordMinIOMove` 方法记录每次移动操作
- ✅ 在 `GetStats` 中返回MinIO监控指标

**监控指标**：
- `minio_move_total`: 总移动次数
- `minio_move_success`: 成功次数
- `minio_move_failed`: 失败次数
- `minio_move_avg_time_ms`: 平均耗时（毫秒）
- `minio_move_max_time_ms`: 最大耗时（毫秒）
- `minio_move_success_rate`: 成功率（0.0-1.0）

**代码位置**：
```go
// monitor.go
type PerformanceMonitor struct {
    // MinIO操作监控（图片移动）
    minIOMoveTotal      int64
    minIOMoveSuccess    int64
    minIOMoveFailed     int64
    minIOMoveTotalTime  int64
    minIOMoveAvgTime    float64
    minIOMoveMaxTime    int64
}

// RecordMinIOMove 记录MinIO图片移动操作
func (m *PerformanceMonitor) RecordMinIOMove(success bool, durationMs int64) {
    // 记录成功/失败和耗时
}
```

**使用**：
```go
// scheduler.go - moveImageToAlertPathInternal
startTime := time.Now()
// ... 执行移动操作 ...
if s.monitor != nil {
    s.monitor.RecordMinIOMove(success, time.Since(startTime).Milliseconds())
}
```

## 📊 性能提升

### 优化前

- **并发数**：无限制（可能达到100+）
- **超时时间**：15秒
- **监控**：无

### 优化后

- **并发数**：限制为50个（可配置）
- **超时时间**：5秒（快速失败）
- **监控**：完整的MinIO操作监控

### 预期效果

1. **减少MinIO压力**：
   - 并发数从无限制降到50个
   - 避免MinIO服务器过载

2. **快速失败**：
   - 超时时间从15秒降到5秒
   - 快速发现和恢复问题

3. **可观测性**：
   - 实时监控MinIO操作性能
   - 可以及时发现性能问题

## 🔍 监控指标使用

### 查看监控指标

```bash
# 通过API查看性能统计
curl http://localhost:5066/api/v1/ai_analysis/inference_stats | jq

# 关注MinIO相关指标：
# - minio_move_total: 总移动次数
# - minio_move_success: 成功次数
# - minio_move_failed: 失败次数
# - minio_move_avg_time_ms: 平均耗时
# - minio_move_max_time_ms: 最大耗时
# - minio_move_success_rate: 成功率
```

### 性能判断

**正常情况**：
- `minio_move_avg_time_ms` < 200ms
- `minio_move_success_rate` > 0.99
- `minio_move_max_time_ms` < 1000ms

**需要关注**：
- `minio_move_avg_time_ms` > 500ms
- `minio_move_success_rate` < 0.95
- `minio_move_max_time_ms` > 2000ms

## 📝 配置说明

### 配置文件

```toml
[ai_analysis]
# 图片移动配置
alert_image_move_concurrent = 50  # 图片移动最大并发数，默认: 50
```

### 配置建议

**低负载场景**（告警频率 < 10个/秒）：
```toml
alert_image_move_concurrent = 20  # 降低并发数
```

**中负载场景**（告警频率 10-50个/秒）：
```toml
alert_image_move_concurrent = 50  # 默认值
```

**高负载场景**（告警频率 > 50个/秒）：
```toml
alert_image_move_concurrent = 100  # 增加并发数（需要MinIO性能支持）
```

## ✅ 总结

**优化状态**: ✅ **已完成**

**优化内容**:
1. ✅ 保持 CopyObject 方案（最优）
2. ✅ 添加并发控制（限制50个并发）
3. ✅ 优化超时时间（从15秒降到5秒）
4. ✅ 添加监控指标（MinIO响应时间、成功率）

**预期效果**:
- ✅ 减少MinIO压力（并发数可控）
- ✅ 快速失败（超时时间缩短）
- ✅ 可观测性提升（完整监控指标）

---

**实现时间**：2025年11月19日  
**实现状态**：✅ 已完成

