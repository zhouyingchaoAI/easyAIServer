# 系统卡顿问题分析报告

## 一、问题现象

系统经常会卡一下，影响用户体验。

## 二、可能的原因分析

### 2.1 清理操作阻塞 🔴 **最可能**

**问题**：
- 清理操作使用冒泡排序，O(n²)复杂度
- 如果图片数量多（如1000张），排序会很慢
- 清理操作是同步的，会阻塞主流程

**代码位置**：
```go
// 按时间排序（从旧到新）
// 使用简单的冒泡排序
for i := 0; i < len(objects)-1; i++ {
    for j := 0; j < len(objects)-i-1; j++ {
        if objects[j].lastMod.After(objects[j+1].lastMod) {
            objects[j], objects[j+1] = objects[j+1], objects[j]
        }
    }
}
```

**影响**：
- 如果图片数量为1000张，冒泡排序需要约50万次比较
- 每次比较涉及时间比较，可能很慢
- 如果图片数量为5000张，需要约1250万次比较
- 这会导致清理操作非常慢，阻塞系统

### 2.2 ListObjects操作阻塞

**问题**：
- MinIO的ListObjects操作可能很慢
- 如果图片数量多，ListObjects会很慢
- 30秒超时可能不够，或者操作本身很慢

**代码位置**：
```go
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

objectCh := s.minio.client.ListObjects(ctx, s.minio.bucket, minio.ListObjectsOptions{
    Prefix:    prefix,
    Recursive: true,
})
```

**影响**：
- 如果图片数量多，ListObjects可能需要几秒甚至几十秒
- 这会阻塞清理操作，导致系统卡顿

### 2.3 MinIO扫描操作阻塞

**问题**：
- 扫描MinIO时，如果图片数量多，ListObjects会很慢
- 扫描间隔0.2秒，如果扫描很慢，会阻塞
- 扫描操作是同步的，会阻塞主流程

**影响**：
- 如果扫描很慢，会影响后续的扫描
- 导致图片无法及时推送到队列

### 2.4 锁竞争

**问题**：
- 多个goroutine同时访问共享资源
- 如果锁持有时间长，会导致其他goroutine等待

**可能的位置**：
- `cleanupMu`：清理操作的锁
- `queueCheckerMu`：队列检查器的锁
- 其他共享资源的锁

**影响**：
- 如果锁持有时间长，会导致其他goroutine等待
- 导致系统响应变慢

### 2.5 同步操作阻塞

**问题**：
- 清理操作是同步的，会阻塞主流程
- 如果清理很慢，会影响其他操作

**影响**：
- 清理操作在主goroutine中执行
- 如果清理很慢，会阻塞其他操作
- 应该异步执行清理操作

## 三、关键问题

### 3.1 冒泡排序性能问题 🔴 **最严重**

**问题**：
- 使用冒泡排序，O(n²)复杂度
- 如果图片数量多，排序会很慢

**示例**：
- 1000张图片：约50万次比较
- 5000张图片：约1250万次比较
- 10000张图片：约5000万次比较

**解决方案**：
- 使用Go的`sort.Slice`，O(n log n)复杂度
- 或者使用快速排序

### 3.2 ListObjects操作可能很慢

**问题**：
- 如果图片数量多，ListObjects会很慢
- 30秒超时可能不够

**解决方案**：
- 优化ListObjects操作
- 或者使用分页查询
- 或者增加超时时间

### 3.3 清理操作是同步的

**问题**：
- 清理操作在主goroutine中执行
- 如果清理很慢，会阻塞其他操作

**解决方案**：
- 异步执行清理操作
- 使用goroutine执行清理

## 四、诊断建议

### 4.1 立即检查

1. ✅ 检查清理操作的耗时
2. ✅ 检查ListObjects操作的耗时
3. ✅ 检查扫描操作的耗时
4. ✅ 检查图片数量（如果数量多，清理会很慢）

### 4.2 关键指标

- **清理耗时** > 5秒：说明清理很慢，可能阻塞
- **ListObjects耗时** > 5秒：说明ListObjects很慢
- **扫描耗时** > 1秒：说明扫描很慢
- **图片数量** > 1000张：说明排序会很慢

### 4.3 问题优先级

1. 🔴 **最高优先级**：修复冒泡排序，使用快速排序
2. ⚠️ **高优先级**：优化ListObjects操作
3. ⚠️ **中优先级**：异步执行清理操作
4. ⚠️ **低优先级**：优化锁竞争

## 五、解决方案

### 5.1 修复冒泡排序

**当前代码**：
```go
// 按时间排序（从旧到新）
// 使用简单的冒泡排序
for i := 0; i < len(objects)-1; i++ {
    for j := 0; j < len(objects)-i-1; j++ {
        if objects[j].lastMod.After(objects[j+1].lastMod) {
            objects[j], objects[j+1] = objects[j+1], objects[j]
        }
    }
}
```

**优化后**：
```go
// 按时间排序（从旧到新）
// 使用Go的sort.Slice，O(n log n)复杂度
sort.Slice(objects, func(i, j int) bool {
    return objects[i].lastMod.Before(objects[j].lastMod)
})
```

**性能提升**：
- 1000张图片：从O(n²)降低到O(n log n)
- 性能提升约100倍

### 5.2 异步执行清理操作

**当前代码**：
```go
// 同步执行清理
err := s.cleanupOldFrames(task, maxCount)
```

**优化后**：
```go
// 异步执行清理
go func() {
    err := s.cleanupOldFrames(task, maxCount)
    if err != nil {
        s.log.Warn("cleanup failed", ...)
    }
}()
```

**优势**：
- 不阻塞主流程
- 清理操作在后台执行

### 5.3 优化ListObjects操作

**当前代码**：
```go
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
```

**优化后**：
- 使用分页查询
- 或者增加超时时间
- 或者优化查询条件

## 六、总结

### 6.1 核心问题

**系统卡顿的主要原因是清理操作中的冒泡排序性能问题**

### 6.2 关键发现

1. 冒泡排序O(n²)复杂度，如果图片数量多会很慢
2. 清理操作是同步的，会阻塞主流程
3. ListObjects操作可能很慢

### 6.3 解决方案

1. 修复冒泡排序，使用快速排序
2. 异步执行清理操作
3. 优化ListObjects操作

