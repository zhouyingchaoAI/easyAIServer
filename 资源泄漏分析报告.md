# 资源泄漏分析报告

## 问题概述
程序运行约1小时后出现异常，可能存在资源持续增长导致的内存泄漏或资源耗尽问题。

## 发现的潜在问题

### 🔴 严重问题：Map持续增长（内存泄漏）

#### 1. `moveLocks` Map 只增不减
**位置**: `internal/plugin/aianalysis/scheduler.go:99`
```go
moveLocks map[string]*sync.Mutex
```

**问题**：
- 每次为新的`task_id`创建移动锁时，都会在map中添加新条目
- **从未清理**：即使任务完成或图片移动完成，锁也不会从map中移除
- 如果系统处理大量不同的`task_id`，这个map会无限增长

**影响**：
- 每个条目占用约40-50字节（string key + mutex指针）
- 假设1小时处理1000个不同的task_id，map会增长到约50KB
- 长期运行会持续增长，最终可能导致内存耗尽

**修复建议**：
- 在移动完成后，延迟清理（使用定时器，比如5分钟后清理）
- 或者限制map大小，使用LRU策略

---

#### 2. `processed` Map 持续增长（EventListener）
**位置**: `internal/plugin/aianalysis/event_listener.go:21`
```go
processed map[string]time.Time // 已处理图片 path -> 处理时间
```

**问题**：
- 每次处理图片都会添加到map中
- **从未清理**：没有过期清理机制
- 如果系统持续运行，map会无限增长

**影响**：
- 每个条目占用约50-100字节（string path + time.Time）
- 假设每秒处理10张图片，1小时 = 36,000条 = 约3.6MB
- 长期运行会持续增长到GB级别

**修复建议**：
- 定期清理过期条目（比如只保留最近1小时的记录）
- 或者限制map大小，使用LRU策略

---

#### 3. `processed` Map 持续增长（Scanner）
**位置**: `internal/plugin/aianalysis/scanner.go:30`
```go
processed map[string]time.Time // 已处理图片 path -> 处理时间
```

**问题**：
- 与EventListener相同的问题
- **从未清理**：没有过期清理机制

**修复建议**：
- 定期清理过期条目（比如只保留最近1小时的记录）

---

#### 4. `pendingInferringImages` Map 可能泄漏
**位置**: `internal/plugin/aianalysis/scheduler.go:51`
```go
pendingInferringImages map[string]bool
```

**问题**：
- 如果图片被Pop后，但`ScheduleInference`没有执行（比如worker异常退出、panic），pending标记可能不会被清理
- 虽然正常情况下会在`ScheduleInference`开始时清理，但异常情况下可能泄漏

**影响**：
- 每个条目占用约50-100字节
- 如果worker频繁异常，可能累积

**修复建议**：
- 添加超时清理机制（比如5分钟后自动清理pending标记）
- 或者在worker异常恢复时清理

---

### 🟡 中等问题：Goroutine泄漏风险

#### 5. 异步推理Goroutine可能泄漏
**位置**: `internal/plugin/aianalysis/service.go:384`
```go
go func(image ImageInfo) {
    scheduleStart := time.Now()
    s.scheduler.ScheduleInference(image)
    // ...
}(img)
```

**问题**：
- 每次推理都会启动一个goroutine
- 如果`ScheduleInference`内部发生panic且未被捕获，goroutine可能异常退出
- 虽然`ScheduleInference`内部有defer清理，但如果panic发生在清理之前，可能导致资源泄漏

**影响**：
- 正常情况下goroutine会正常结束
- 异常情况下可能累积

**修复建议**：
- 在goroutine中添加panic恢复机制
- 确保所有资源清理都在defer中

---

#### 6. 异步图片移动Goroutine可能泄漏
**位置**: `internal/plugin/aianalysis/scheduler.go:578`
```go
go func(srcPath, dstPath, taskID, taskType, filename string) {
    lock := s.getMoveLock(taskID)
    lock.Lock()
    defer lock.Unlock()
    // ...
}(image.Path, targetAlertPath, image.TaskID, image.TaskType, image.Filename)
```

**问题**：
- 如果移动操作失败或异常，goroutine可能异常退出
- 虽然使用了defer，但如果panic发生在defer之前，可能导致资源泄漏

**影响**：
- 正常情况下goroutine会正常结束
- 异常情况下可能累积

**修复建议**：
- 在goroutine中添加panic恢复机制

---

### 🟢 轻微问题：Context和HTTP连接

#### 7. Context清理
**状态**：✅ 大部分context都有defer cancel，但需要确认所有路径都正确清理

#### 8. HTTP连接池
**状态**：✅ 使用了`DisableKeepAlives: true`，每次使用新连接，不会累积连接

---

## 资源增长估算

### 1小时内资源增长（假设每秒处理10张图片）

| 资源类型 | 增长量 | 说明 |
|---------|--------|------|
| `moveLocks` | ~50KB | 假设1000个不同的task_id |
| `eventListener.processed` | ~3.6MB | 36,000条记录 |
| `scanner.processed` | ~3.6MB | 36,000条记录 |
| `pendingInferringImages` | ~0-1MB | 取决于异常情况 |
| **总计** | **~7-8MB/小时** | 持续增长 |

### 长期运行影响
- **24小时**：~200MB
- **7天**：~1.4GB
- **30天**：~6GB

**结论**：虽然单小时增长不大，但长期运行会导致内存持续增长，最终可能导致OOM。

---

## 修复优先级

### 🔴 高优先级（必须修复）
1. **`moveLocks` Map清理** - 会持续增长，必须修复
2. **`processed` Map清理（EventListener）** - 会持续增长，必须修复
3. **`processed` Map清理（Scanner）** - 会持续增长，必须修复

### 🟡 中优先级（建议修复）
4. **`pendingInferringImages`超时清理** - 异常情况下可能泄漏
5. **Goroutine panic恢复** - 提高系统稳定性

### 🟢 低优先级（可选）
6. **Context清理检查** - 大部分已正确实现

---

## 修复方案

### 方案1：定期清理Map（推荐）
为每个Map添加定期清理机制，只保留最近N小时的记录。

### 方案2：限制Map大小（备选）
使用LRU策略，限制Map最大大小，自动淘汰最旧的条目。

### 方案3：超时清理（针对pending标记）
为pending标记添加超时机制，超过5分钟自动清理。

---

## 建议

1. **立即修复**：`moveLocks`、`processed`（EventListener和Scanner）的清理机制
2. **监控内存**：添加内存监控，定期输出各Map的大小
3. **压力测试**：运行24小时压力测试，验证修复效果
4. **添加告警**：当Map大小超过阈值时告警

