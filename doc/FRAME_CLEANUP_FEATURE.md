# 抽帧图片自动清理功能

## 功能概述

为防止抽帧图片积累过多占用存储空间，本功能实现了基于数量限制的自动清理机制。当任务的抽帧图片数量超过配置的上限时，系统会自动删除最早的图片，保留最新的图片。

## 主要特性

1. **可配置的图片数量上限**
   - 支持全局默认配置
   - 支持每个任务单独配置
   - 任务级配置优先于全局配置

2. **智能清理策略**
   - 按时间顺序删除，保留最新的图片
   - 自动排除预览图和配置文件
   - 异步清理，不阻塞上传流程

3. **性能优化**
   - 限流机制：每上传50张图片或每5分钟触发一次清理
   - 避免频繁的MinIO列表操作
   - 异步执行，不影响抽帧性能

## 配置说明

### 全局配置

在 `config.toml` 的 `[frame_extractor]` 部分添加：

```toml
[frame_extractor]
enable = true
interval_ms = 1000
output_dir = './snapshots'
store = 'minio'
task_types = ['人数统计', '绊线人数统计', '人员跌倒', '人员离岗', '吸烟检测', '区域入侵', '徘徊检测', '物品遗留', '安全帽检测']

# 全局默认最大抽帧图片数量（0表示不限制）
max_frame_count = 500
```

### 任务级配置

在每个任务配置中可以单独设置：

```toml
[[frame_extractor.tasks]]
id = '测试任务1'
task_type = '人数统计'
rtsp_url = 'rtsp://admin:password@192.168.1.100:554/stream'
interval_ms = 200
output_path = '测试任务1'
enabled = true

# 任务级最大图片数量（0表示使用全局配置）
max_frame_count = 300  # 此任务最多保留300张图片
```

```toml
[[frame_extractor.tasks]]
id = '测试任务2'
task_type = '人数统计'
rtsp_url = 'rtsp://admin:password@192.168.1.101:554/stream'
interval_ms = 200
output_path = '测试任务2'
enabled = true

# 使用全局配置（500张）
max_frame_count = 0
```

## 配置参数说明

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `max_frame_count` (全局) | int | 0 | 全局默认最大图片数量，0表示不限制 |
| `max_frame_count` (任务级) | int | 0 | 任务级最大图片数量，0表示使用全局配置 |

## 工作原理

### 清理触发条件

清理操作在以下情况下触发（满足任一条件）：

1. 累计上传50张图片
2. 距离上次清理超过5分钟

### 清理流程

1. **列出图片**：列出任务目录下的所有.jpg文件
2. **过滤文件**：排除预览图（preview_*.jpg）和其他非抽帧图片
3. **排序**：按最后修改时间排序（从旧到新）
4. **删除**：如果总数超过限制，删除最旧的图片，保留最新的N张
5. **日志记录**：记录删除的图片数量和保留的图片数量

### 示例场景

假设配置 `max_frame_count = 500`，抽帧间隔为200ms（每秒5帧）：

- **累积时间**：500张图片 ÷ 5张/秒 = 100秒
- **清理频率**：每上传50张图片触发一次（约10秒）
- **删除数量**：如果有550张图片，会删除最旧的50张，保留最新的500张

## 技术实现

### 核心文件

1. **配置模型**：`internal/conf/model.go`
   - 添加 `MaxFrameCount` 配置字段
   - 支持全局和任务级配置

2. **清理逻辑**：`internal/plugin/frameextractor/minio.go`
   - `cleanupOldFrames()`: 执行清理操作
   - `shouldCleanup()`: 限流控制
   - `getMaxFrameCount()`: 获取有效配置值

3. **服务管理**：`internal/plugin/frameextractor/service.go`
   - 添加清理计数器
   - 任务删除时清理计数器

### 关键代码逻辑

```go
// 上传图片后触发清理检查
if maxCount > 0 && s.shouldCleanup(task.ID) {
    go func(t conf.FrameExtractTask, max int) {
        if err := s.cleanupOldFrames(t, max); err != nil {
            s.log.Warn("cleanup failed", ...)
        }
    }(task, maxCount)
}
```

## 性能考虑

1. **异步清理**：清理操作在单独的goroutine中执行，不阻塞抽帧上传
2. **限流机制**：避免每次上传都触发清理，减少MinIO API调用
3. **批量删除**：一次清理操作删除多张图片，提高效率
4. **超时控制**：每个MinIO操作都设置了合理的超时时间

## 使用建议

1. **设置合理的上限**：
   - 根据抽帧间隔和保留时长计算
   - 例如：1秒间隔，保留1小时 = 3600张
   - 例如：200ms间隔，保留10分钟 = 3000张

2. **平衡存储和数据完整性**：
   - 上限过小：可能删除还未被AI分析的图片
   - 上限过大：占用过多存储空间
   - 建议：根据AI分析速度设置，确保图片被分析后再删除

3. **监控日志**：
   - 关注清理日志，了解清理频率和删除数量
   - 日志级别：INFO 级别会记录清理操作

## 日志示例

```
INFO cleaned up old frames task=测试1 deleted=52 remaining=500 limit=500
DEBUG deleted old frame task=测试1 key=人数统计/测试1/20251105-100000.001.jpg
```

## 注意事项

1. **首次清理**：任务启动后，首次达到上限时才会触发清理
2. **预览图保护**：预览图（preview_*.jpg）不会被清理
3. **配置文件保护**：algo_config.json等配置文件不会被清理
4. **并发安全**：使用互斥锁保护计数器，支持多任务并发清理
5. **MinIO依赖**：本功能仅适用于使用MinIO存储的场景

## 故障排查

### 图片未被清理

1. 检查 `max_frame_count` 是否大于0
2. 检查日志，确认是否有清理操作记录
3. 检查MinIO连接是否正常

### 清理过于频繁

- 默认每50张图片触发一次，如需调整，可修改 `cleanupThreshold` 常量

### 清理失败

- 检查MinIO权限，确保有删除对象的权限
- 查看错误日志，了解具体失败原因

## 版本信息

- **实现日期**：2025-11-05
- **版本**：v1.0
- **支持存储**：MinIO（本地存储支持待后续添加）

## 未来优化

1. 支持本地存储的清理机制
2. 支持基于时间的清理策略（如保留最近N小时的图片）
3. 支持基于存储空间的清理策略
4. 提供清理统计API接口
5. 支持手动触发清理操作

