# 清理策略优化报告

## 一、问题分析

### 1.1 问题现象

快照抽帧数量越来越多，清理机制没有正常工作。

### 1.2 根本原因

**队列保护机制过于激进**：
- 当前保护了队列中所有图片（包括等待的）
- 如果队列积压严重，大量图片被跳过清理
- 导致清理机制失效，图片数量持续增长

**问题链**：
```
队列积压 → 大量图片在队列中等待 → 清理时跳过这些图片 → 实际清理数量很少 → 图片数量持续增长
```

### 1.3 数据支持

- 当前队列大小: 254/50000（0.51%）
- 如果队列中有大量图片，清理时会跳过这些图片
- 从日志看，清理时跳过的图片数量可能远大于删除的数量

## 二、优化方案

### 2.1 核心思路

**只保护正在推理的图片，不保护队列中等待的图片**：
- 正在推理的图片：已从队列Pop，正在调用算法服务
- 队列中等待的图片：还在队列中，还没有开始推理

**理由**：
1. 队列中等待的图片可以清理，因为：
   - 它们还没有开始推理
   - 如果清理了，扫描器会重新发现它们（如果还在MinIO中）
   - 或者，如果队列满了，它们会被丢弃
2. 正在推理的图片必须保护，因为：
   - 推理过程中图片被删除会导致推理失败
   - 这是真正需要保护的图片

### 2.2 技术实现

1. **在Scheduler中跟踪正在推理的图片**：
   ```go
   type Scheduler struct {
       // ...
       inferringImages map[string]bool  // 正在推理的图片集合
       inferringMu     sync.RWMutex     // 保护inferringImages的锁
   }
   ```

2. **在ScheduleInference开始时标记**：
   ```go
   // 标记图片正在推理
   normalizedPath := strings.ReplaceAll(image.Path, "\\", "/")
   s.inferringMu.Lock()
   s.inferringImages[normalizedPath] = true
   s.inferringMu.Unlock()
   
   // 确保推理完成后移除标记
   defer func() {
       s.inferringMu.Lock()
       delete(s.inferringImages, normalizedPath)
       s.inferringMu.Unlock()
   }()
   ```

3. **修改队列检查器**：
   ```go
   // 只保护正在推理的图片，不保护队列中等待的图片
   fxService.SetQueueChecker(func(imagePath string) bool {
       return s.scheduler.IsImageInferring(imagePath)
   })
   ```

## 三、预期效果

### 3.1 清理效果

- **优化前**：保护队列中所有图片，如果队列积压，清理失效
- **优化后**：只保护正在推理的图片，队列中等待的图片可以清理

### 3.2 图片数量控制

- **优化前**：图片数量持续增长，无法控制
- **优化后**：图片数量可以控制在`max_frame_count`限制内

### 3.3 推理稳定性

- **优化前**：队列中等待的图片被保护，但可能永远不会被推理
- **优化后**：只保护正在推理的图片，确保推理时图片存在

## 四、实施步骤

### 4.1 代码修改

1. ✅ 在`Scheduler`中添加`inferringImages`字段
2. ✅ 在`ScheduleInference`中标记和移除正在推理的图片
3. ✅ 添加`IsImageInferring`方法
4. ✅ 修改队列检查器，只检查正在推理的图片

### 4.2 测试验证

1. ⏳ 重新编译并部署
2. ⏳ 监控图片数量是否控制在限制内
3. ⏳ 验证正在推理的图片是否被保护
4. ⏳ 验证队列中等待的图片是否可以被清理

## 五、注意事项

### 5.1 路径规范化

- 确保路径格式一致（使用`strings.ReplaceAll`或`filepath.ToSlash`）
- 在标记和检查时使用相同的路径格式

### 5.2 并发安全

- 使用`sync.RWMutex`保护`inferringImages`
- 确保标记和移除操作是原子的

### 5.3 异常处理

- 使用`defer`确保推理完成后移除标记
- 即使推理失败，也要移除标记

## 六、总结

### 6.1 核心优化

**从保护队列中所有图片 → 只保护正在推理的图片**

### 6.2 预期效果

- 图片数量可以控制在`max_frame_count`限制内
- 清理机制可以正常工作
- 正在推理的图片不会被清理

### 6.3 下一步

1. 重新编译并部署
2. 监控优化后的实际效果
3. 根据实际情况进一步调优

