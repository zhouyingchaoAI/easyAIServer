# 队列为空但算法无请求问题 - 解决方案

## 问题根本原因

1. **队列机制**：新图片入队后，立即被300个worker取走（Pop），但worker使用goroutine异步处理
2. **清理冲突**：Frame Extractor的清理策略（max_frame_count=200）只保留约40秒的图片
3. **时间差问题**：Worker取出的图片在异步处理时，图片已被清理，导致：
   - 大量goroutine在等待处理不存在的图片
   - 推理请求从未发送到算法服务
   - 队列看起来为空，但实际有大量积压的异步任务

## 解决方案（按优先级）

### 方案1：在Pop时立即检查图片是否存在（推荐，立即生效）

**原理**：在worker从队列Pop出图片后，立即检查图片是否存在。如果不存在，直接跳过，不启动异步goroutine。

**优点**：
- 避免启动无用的goroutine
- 让worker能立即处理下一张图片
- 提高处理效率

**实现位置**：`internal/plugin/aianalysis/service.go` 的 `inferenceProcessLoop` 方法

**修改点**：
- 在Pop后、启动goroutine前，先检查图片是否存在
- 如果不存在，直接continue，不启动goroutine

### 方案2：增加图片保留时间（临时方案）

**原理**：增加max_frame_count，让图片保留更长时间，给推理留出足够时间。

**优点**：
- 简单直接，无需改代码
- 立即生效

**缺点**：
- 增加MinIO存储压力
- 治标不治本

**实现**：修改 `configs/config.toml`
```toml
max_frame_count = 1000  # 从200增加到1000，保留约200秒的图片
```

### 方案3：优化清理逻辑，确保队列保护生效（已实现，需验证）

**原理**：Frame Extractor清理时，通过queueChecker回调检查图片是否在队列中。

**当前实现**：已在 `service.go:196-205` 实现，保护队列中的图片。

**验证方法**：
- 检查日志中是否有 "skipping cleanup for image in inference queue"
- 如果没有，说明保护机制可能未生效

### 方案4：清空队列，重新开始（紧急恢复）

**原理**：清空当前队列，让系统重新开始处理新图片。

**实现**：需要添加API接口或重启服务

## 推荐执行顺序

1. **立即执行**：方案2（增加max_frame_count到1000）
2. **短期修复**：方案1（在Pop时立即检查）
3. **长期优化**：方案3（验证并优化清理保护机制）

